# -*- coding: utf-8 -*-
"""Predictive Anlysis Predictive analysis Sales Supermarket.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x9oyEq_6k7y2vDlHi8pca1o_q8bOrK-q

##Rahmat Hidayat
##Submission Dicoding Predictive analysis Sales Supermarket

##Pertama, import library yang dibutuhkan. Anda dapat melakukannya di awal, atau di tiap kode sel.
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import seaborn as sns

"""# Crawling Data"""

url = "https://github.com/Rahmathidayat4299/data-machine-learning/raw/refs/heads/master/supermarket_sales%20-%20Sheet1.csv"
salesmarket = pd.read_csv(url)
salesmarket

"""# Konversi Tinggi

# Cleaning Process Data
Proses membersihkan data mulai dari pengecekan :

*   Pengecekan null pada data
*   Pengecekan duplicated pada data
*   Pengecekan Outlier pada data

Data yang bersih akan memudah melatih model dan menghasilkan prediksi yang baik
"""

salesmarket.describe()
checkbodynull = salesmarket.isnull().sum()
checkbodyduplicate = salesmarket.duplicated().sum()
checkbodynull
checkbodyduplicate

"""# Penanganan Outlier"""

import pandas as pd

# Menentukan kolom yang relevan untuk cek outlier
numerical_columns = ['Unit price', 'Quantity', 'Total', 'Rating']

# Menghitung Q1 (Kuartil Pertama) dan Q3 (Kuartil Ketiga)
Q1 = salesmarket[numerical_columns].quantile(0.25)
Q3 = salesmarket[numerical_columns].quantile(0.75)

# Menghitung IQR (Interquartile Range)
IQR = Q3 - Q1

# Menentukan batas bawah dan batas atas untuk mendeteksi outlier
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Menampilkan outlier pada masing-masing kolom
outliers = salesmarket[
    (salesmarket['Unit price'] < lower_bound['Unit price']) | (salesmarket['Unit price'] > upper_bound['Unit price']) |
    (salesmarket['Quantity'] < lower_bound['Quantity']) | (salesmarket['Quantity'] > upper_bound['Quantity']) |
    (salesmarket['Total'] < lower_bound['Total']) | (salesmarket['Total'] > upper_bound['Total']) |
    (salesmarket['Rating'] < lower_bound['Rating']) | (salesmarket['Rating'] > upper_bound['Rating'])
]

# Menampilkan outlier yang terdeteksi
print("Jumlah outlier pada DataFrame:", len(outliers))
print(outliers)

from scipy import stats
import numpy as np

# Menghitung Z-score untuk kolom numerik
z_scores = np.abs(stats.zscore(salesmarket[numerical_columns]))

# Menyaring outlier berdasarkan Z-score > 3
outliers_zscore = salesmarket[(z_scores > 3).any(axis=1)]

# Menampilkan outlier yang terdeteksi
print("Jumlah outlier pada DataFrame berdasarkan Z-score:", len(outliers_zscore))
print(outliers_zscore)

# Menghapus outlier berdasarkan batas bawah dan atas
salesmarketclean = salesmarket[
    (salesmarket['Unit price'] >= lower_bound['Unit price']) & (salesmarket['Unit price'] <= upper_bound['Unit price']) &
    (salesmarket['Quantity'] >= lower_bound['Quantity']) & (salesmarket['Quantity'] <= upper_bound['Quantity']) &
    (salesmarket['Total'] >= lower_bound['Total']) & (salesmarket['Total'] <= upper_bound['Total']) &
    (salesmarket['Rating'] >= lower_bound['Rating']) & (salesmarket['Rating'] <= upper_bound['Rating'])
]

# Menampilkan jumlah data setelah penghapusan outlier
print("Jumlah data setelah outlier dihapus:", len(salesmarketclean))

# Menampilkan beberapa data setelah outlier dihapus
print(salesmarketclean.head())

salesmarketclean.describe()
salesmarketclean.info()
salesmarketclean.duplicated().sum()

"""# Menjawab Pertanyaan
  ## Bagaimana kita bisa memprediksi total penjualan (Total) dari kombinasi variabel seperti jenis pelanggan, jenis produk, dan lokasi cabang?
"""

# Mengubah variabel kategorikal menjadi numerik menggunakan One-Hot Encoding
df_encoded = pd.get_dummies(salesmarketclean, columns=['Customer type', 'Product line', 'Branch', 'City', 'Gender', 'Payment'], drop_first=True)

"""#Model Development
#Langkah 1: Memisahkan Fitur dan Target
Selanjutnya, kita pisahkan fitur (X) dan target (y), di mana target adalah variabel Total.
"""

# Menentukan fitur dan target
X = df_encoded.drop(columns=['Total', 'Invoice ID', 'Date', 'Time'])  # Menghapus kolom yang tidak relevan
y = df_encoded['Total']

"""## Langkah 2: Membagi Data untuk Pelatihan dan Pengujian
Kita perlu membagi data menjadi data pelatihan dan data pengujian untuk mengevaluasi kinerja model.
"""

from sklearn.model_selection import train_test_split

# Membagi data menjadi training set dan testing set
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""# Langkah 3: Membangun Model Regresi
## Regresi Linier
Kita bisa memulai dengan Regresi Linier untuk memprediksi total penjualan berdasarkan fitur-fitur yang ada.
"""

from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score

# Membangun model regresi linier
linear_model = LinearRegression()

# Melatih model
linear_model.fit(X_train, y_train)

# Melakukan prediksi pada data uji
y_pred_linear = linear_model.predict(X_test)

# Mengukur kinerja model
mse_linear = mean_squared_error(y_test, y_pred_linear)
r2_linear = r2_score(y_test, y_pred_linear)

print(f'Mean Squared Error (Linear Regression): {mse_linear}')
print(f'R-squared (Linear Regression): {r2_linear}')

"""# Xgboost"""

import xgboost as xgb

# Membangun model XGBoost
xgboost_model = xgb.XGBRegressor(objective ='reg:squarederror', random_state=42)

# Melatih model
xgboost_model.fit(X_train, y_train)

# Melakukan prediksi pada data uji
y_pred_xgb = xgboost_model.predict(X_test)

# Mengukur kinerja model
mse_xgb = mean_squared_error(y_test, y_pred_xgb)
r2_xgb = r2_score(y_test, y_pred_xgb)

print(f'Mean Squared Error (XGBoost): {mse_xgb}')
print(f'R-squared (XGBoost): {r2_xgb}')

"""# Validasi Model:

Cross-Validation: Lakukan k-fold cross-validation untuk memastikan model Anda konsisten pada berbagai subset data.
"""

from sklearn.model_selection import cross_val_score

cv_scores = cross_val_score(xgboost_model, X_train, y_train, cv=5, scoring='r2')
print("Cross-validation R² scores:", cv_scores)
print("Mean R² score:", cv_scores.mean())

"""# Analisis Feature Importance:
*   Identifikasi fitur mana yang paling berpengaruh terhadap prediksi total penjualan.
*   Fitur Unit price, Tax 5%, dan Rating adalah yang paling berpengaruh dalam model, yang menunjukkan bahwa harga dan pajak memainkan peran kunci dalam memprediksi total penjualan.
* Fitur-fitur lain seperti Quantity, tipe pelanggan, dan metode pembayaran memberikan kontribusi yang lebih kecil, namun masih relevan untuk meningkatkan akurasi prediksi.

"""

import matplotlib.pyplot as plt
xgb.plot_importance(xgboost_model, max_num_features=10)
plt.show()

"""# Hyperparameter Tuning:
 meningkatkan performa model melalui hyperparameter tuning menggunakan Grid Search atau Random Search.
"""

from sklearn.model_selection import GridSearchCV

param_grid = {
    'n_estimators': [100, 200, 500],
    'max_depth': [3, 5, 7],
    'learning_rate': [0.01, 0.1, 0.2],
    'subsample': [0.7, 0.8, 1.0],
    'colsample_bytree': [0.7, 0.8, 1.0]
}

grid_search = GridSearchCV(
    estimator=xgboost_model,
    param_grid=param_grid,
    scoring='neg_mean_squared_error',
    cv=5,
    n_jobs=-1,
    verbose=1
)

grid_search.fit(X_train, y_train)
print("Best parameters found: ", grid_search.best_params_)

import xgboost as xgb
# Melatih ulang model dengan parameter terbaik
xgb_best = xgb.XGBRegressor(
    colsample_bytree=0.8,
    learning_rate=0.1,
    max_depth=5,
    n_estimators=100,
    subsample=0.7
)

# Fit ulang model dengan data pelatihan
xgb_best.fit(X_train, y_train)

# Melakukan prediksi pada test set
y_pred = xgb_best.predict(X_test)

# Evaluasi performa model
from sklearn.metrics import mean_squared_error, r2_score

mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Squared Error (MSE): {mse}")
print(f"R-squared: {r2}")

"""#Evaluasi Model
## Visualisasi Hasil Prediksi
Grafik ini menunjukkan bagaimana hasil prediksi dibandingkan dengan nilai aktual. Idealnya, jika model Anda sempurna, semua titik akan berada pada garis 45 derajat (prediksi = nilai aktual).
"""

import matplotlib.pyplot as plt

# Plot Prediksi vs Nilai Aktual
plt.figure(figsize=(8, 6))
plt.scatter(y_test, y_pred, alpha=0.3)
plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], color='red', linestyle='--', lw=2)
plt.xlabel('Nilai Aktual')
plt.ylabel('Nilai Prediksi')
plt.title('Prediksi vs Nilai Aktual')
plt.show()

"""# Residual Plot:
Residual plot dapat membantu mengidentifikasi pola dari error model. Residual adalah selisih antara nilai aktual dan prediksi. Plot residual yang tersebar secara acak di sekitar 0 menunjukkan bahwa model memprediksi dengan baik dan tidak ada pola sistematis dalam error.
"""

# Menghitung residual
residuals = y_test - y_pred

# Plot Residuals
plt.figure(figsize=(8, 6))
plt.scatter(y_pred, residuals, alpha=0.3)
plt.axhline(y=0, color='red', linestyle='--', lw=2)
plt.xlabel('Nilai Prediksi')
plt.ylabel('Residual (Nilai Aktual - Prediksi)')
plt.title('Plot Residual')
plt.show()

"""# Distribusi Error (Histogram dari Residual):
Dengan melihat distribusi residual, Anda bisa mengecek apakah error tersebar dengan normal, yang mengindikasikan model yang baik.
"""

# Plot distribusi residual (error)
plt.figure(figsize=(8, 6))
plt.hist(residuals, bins=30, color='blue', alpha=0.7)
plt.xlabel('Residual (Nilai Aktual - Prediksi)')
plt.ylabel('Frekuensi')
plt.title('Distribusi Residual')
plt.show()

"""# Mean Absolute Error (MAE) dan Root Mean Squared Error (RMSE) untuk memahami performa model.

Mean Absolute Error (MAE) memberikan rata-rata absolut error yang lebih mudah diinterpretasikan karena tidak memberikan penalti lebih tinggi untuk outlier.
Root Mean Squared Error (RMSE) adalah akar kuadrat dari MSE dan memberikan gambaran yang lebih intuitif terkait dengan skala error.
"""

from sklearn.metrics import mean_absolute_error
import numpy as np

mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mse)

print(f"Mean Absolute Error (MAE): {mae}")
print(f"Root Mean Squared Error (RMSE): {rmse}")